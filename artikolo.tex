\documentclass[utf8]{scrartcl}

\usepackage{fontspec}

\usepackage{polyglossia}
\setdefaultlanguage{esperanto}
\usepackage{lmodern}
\usepackage{tikz}
\usetikzlibrary{automata, positioning, arrows, calc}
\usepgflibrary{fpu}
\pgfdeclarelayer{bg}    % declare background layer
\pgfsetlayers{bg,main}

\usepackage{amsfonts}
\usepackage{amsmath}

\DeclareMathOperator{\pgkd}{pgkd}

\RequirePackage{ifthen}

\makeatletter
\renewenvironment{figure}[1][]{%
  \ifthenelse{\equal{#1}{}}{%
    \@float{figure}%
  }{%
    \@float{figure}[#1]%
  }%
  \centering%
}{%
\end@float\ignorespaces\ignorespacesafterend%
}
\makeatother

\usepackage{caption}
\captionsetup{%
  textfont={sf,it,footnotesize},%
  labelfont={sf,bf,footnotesize},
  width=0.75\linewidth
}
\captionsetup[subfloat]{margin=0pt}


\title{Postkvantuma ĉifrado}
\author{Johannes Mueller}
\date{}

\begin{document}
\maketitle

\section{Enkonduko}

Ĉifrado estas grava parto de nia nuntempa kulturo kaj socio.  Ĝi apartenas al
la pli vasta temaro de datuma sekureco kaj datuma protektado.  Oni okupiĝas pri
tiu temaro ĉefe celante la tri jenajn celojn:
%
\begin{description}
\item[konfidenteco] neniu necelata povas legi la datumojn
\item[fidindeco] pruveblo de la deveno kaj la aŭtenteco
\item[disponeblo] disponebla kiam bezonataj
\end{description}

Ĉiuj tri de tiuj celoj estas gravaj por la funkciado de la nuntempa socio.  Ni
ĉiuj fidas je tio, ke niaj komunikaĵoj privataj kaj ankaŭ ekzemple la sekretoj
kiel pasvortoj ne estu alireblaj por krimuloj – konfidenteco. Same gravas ke
neniu krimulo povu falsi ekzemple nian komunikon kun la bankoj – fidindeco.
Kaj trie, gravas ke signifaj datumoj estu je dispono kiam bezonataj. Se ne, tutaj
malsanulejoj, flughavenoj aŭ fevojsistemoj ĉesas funkcii.

Por du el tiuj tri datumprotektaj celoj, la konfidenteco kaj la fidindeco,
ĉifrado ludas ĉefan rolon.

\subsection{Terminologio}

Komence ni enkonduku kelkajn terminojn.
%
\begin{description}
\item[klarmesaĝo] la neĉifrita mesaĝo, legebla por ĉiuj
\item[ĉifraĵo] la ĉifrita mesaĝo, legebla nur por tiuj kiuj havas la ŝlosilon
\item[ĉifri] transformi klarmesaĝon al ĉifraĵo per ŝlosilo
\item[malĉifri] transformi ĉifraĵon al klarmesaĝo per ŝlosilo
\item[ŝlosilo] datumo por ĉifri aŭ malĉifri mesaĝon
\item[haketo] testsumo por pruvi ĉu mesaĝo estas aŭtenta
\item[subskribo] pruvilo ke mesaĝo kaj la deveno estas aŭtentaj
\end{description}



\section{Bazoj de ĉifrado}

La bazaj principoj de la moderna ĉifrado estis vortumitaj unue de Kerckoff:
%
\begin{itemize}
\item La sistemo ne estu sekreta (nur la ŝlosilo). Oni devas supozi ke la
  atakanto scias kiel niaj ĉifrosistemoj funkcias. Krome ili estu publikaj, por
  ke spertuloj povu esplori ilin por taksi la sekurecon.
\item La ĉifraĵo ne estu distingebla de hazarda datumo.
\item La ĉifraĵo estu transsendebla elektronike.
\item La sistemo estu transportebla kaj uzebla pere de unu persono.
\item La sistemo estu facile uzebla.
\end{itemize}


\subsection{Simetria ĉifrado}

La simetria ĉifrado estas la pli facile komprenebla. Oni malĉifras la ĉifraĵon
per la sama ŝlosilo per kiu oni ĉifris la klarmesaĝon.  Tio estas ekzemple tre
taŭga por ĉifri la datumoj sur durdiskoj aŭ similaj datumujoj.  Kiam oni laĉas
la komputilon aŭ aligas datumujon, oni devas iamaniere enigi la ŝlosilon,
ekzemple per tajpante ĝin. Poste la komputilo aŭtomate ĉifras ĉiujn skribaĵojn
al la disko kaj malĉifras ĉiuj legaĵojn.  Simetriaj ĉifrosistemoj estas tre
rapidaj, kaj devas esti tre rapidaj, ĉar malrapida aliro al durdisko bremsus la
tutan sperton de komputila uzado.

La granda malavantaĝo de simetria ĉifrado estas, ke la du komunikpartneroj
devas interŝanĝi la ŝlosilon. Tio estas malfacila, ĉar por tio ja ankoraŭ ne
ekzistas sekura komunikkanalo. Atakanto povus intercepti la ŝlosilon antaŭ la
unua vera mesaĝo estas transsendata.

\begin{figure}
  \begin{tikzpicture}[
    ->,>=stealth,shorten >=1pt,
    auto,
    node distance=5cm,
    ]
    \node [fill=green!33] (km) {Klarmesaĝo $K$};
    \node [fill=red!33, right of=km] (cf) {Ĉifraĵo $M$};

    \draw (km) edge[bend left] node {$f_C(K, S)$} (cf);
    \draw (cf) edge[bend left] node {$f_M(M, S)$} (km);
  \end{tikzpicture}
  \caption{La principo de simetria ĉifrado. Ambaŭ, ĉifro kaj malĉifro estas
    farata per la sama ŝlosilo $S$}.
\end{figure}

\subsection{Malsimetria ĉifrado}

Malsimetria ĉifrado solvas la problemon de la interŝanĝo de la ŝlosiloj. Oni
havas unu ŝlosilon por ĉifri la mesaĝon – la publikan ŝlosilon. Por malĉifri la
mesaĝon oni bezonas la privatan ŝlosilon.  Por partopreni la komunikadon oni
unue devas krei tian ŝlosilparon kaj doni la publikan ŝlosilon al la
komunikpartnero.  Same oni riecevas de la komunikpartnero ties publikan
ŝlosilon por ĉifri mesaĝojn.

La malavantaĝo de malsimetria ĉifrado estas, ke ĝi estas multi pli malrapida aŭ
bezonas pli da komputila potenco.  En la praktiko oni uzas kombinon de ambaŭ
sistemoj. Oni kreas hazardan simetrian ŝlosilon. Per ĝi oni ĉifras la mesaĝon
kaj poste ĉifras nur la simetrian ŝlosilon per la publika ŝlosilo de la
komunikpartnero.  Tiu poste uzas sian privatan ŝlosilon por malĉifri la
simetrian ŝlosilon kaj per ĝi malĉifras la mesaĝon.
%
\begin{figure}
  \begin{tikzpicture}[node distance=0.5em,align=left]

    \node (anjo) at (0,0) {Anjo};
    \node (boĉjo) at (6,0) {Boĉjo};
    \node (publika) at ($(anjo)!0.5!(boĉjo)$) {publiko};

    \node [below=of anjo] (priv) {$S_{priv}$};
    \node [below=of priv] (pub_a) {$S_{pub} = P(S_{priv})$};
    \node (pub_b) at (pub_a -| boĉjo) {$S_{pub}$};
    \node (pub) at ($(pub_a)!0.5!(pub_b)$) {$S_{pub}$};

    \draw[->] (pub_a) -- (pub);

    \draw[->] (pub) -- (pub_b);


    \node [below=of pub_b] (klar) {$K$};

    \node [below=of klar] (cf_b) {$M = f_C(K, S_{pub})$};

    \node (cf_a) at (cf_b -| anjo) {$M$};
    \draw[->] (cf_b) -- (cf_a);

    \node [below=of cf_a] (mcf) {$K = f_M(M, S_{priv})$};

    \begin{pgfonlayer}{bg}
      \fill [fill=red!20]
      ($(anjo) + (-4em,2em)$) rectangle ($(mcf) + (4em, -2em)$) coordinate (anjo border);

      \fill [fill=green!20]
      (anjo border) rectangle ($(boĉjo) + (-4em, 2em)$) coordinate (boĉjo border);

      \fill [fill=magenta!20]
      ($(boĉjo) + (4em, 2em)$) rectangle (anjo border -| boĉjo border);
    \end{pgfonlayer}

  \end{tikzpicture}
  \caption{La principo de malsimetria ĉifrado}
\end{figure}

Estas grave emfazi, ke la tiaj ĉifrosistemo estas io tute ĉiutaga. Ĉiu
retumilo, ĉiu retpoŝta programo, multaj tujmesaĝilo (Telegramo kutime ne)
aplikas tiaspecan ĉifradon aŭtomate.


\section{Matematikaj principoj de ĉifrado}

En la antaŭa ĉapitro ni konstatis, ke por simetria ĉifrado oni devas krei
ŝlosilan paron de privata kaj publika ŝlosilo.  Gravas, certe, ke la privata
ŝlosilo ne estu kalkulebla de la publika. Ni povas imagi, ke ni elektas
hazardan privatan ŝlosilon kaj el ĝi kalkulas la publikan. Ni do bezonas kion
oni nomas \emph{unudirektan funkcion}.  Tio estas matematika funkcio, kiu estas
facile kalkulebla, sed multe malplifacile inversebla.

Ekzemplo por tia unudirekta funkcio estas la produkto de du primoj.  Kalkuli la
produkton de du primoj estas facila. Estas unu multobliga operacio.  La
inverso, la faktorigo – havante la produkton de du primoj trovi la du primajn
faktorojn estas multi malpli facila, ĉar oni fakte devas elprovi ĉiujn eblojn.
Ekzemple sciante du primojn $1475707273$ kaj $6077236961$ oni povas fulmrapide
eĉ per la plej simpla poŝkalkulilo kalkulo la produkton. La faktorigo,
t.e. sciante ke $8968222783092117353$ estas produkto de du primoj, trovi tiujn
primojn estas multe malpi facila. Plie la komplekseco – la bezonata laboro por
la faktorigo – kreskas pli rapide ol tiu por la multobligo.

Po havi ian impreson pri la ciferoj jen ekzemplo. En la jaro 2020 oni starigis
la rekordon por faktorigo. Oni faktorigis 250-ciferan, t.s. 829bitan nombron en
2700 procesilaj horoj Intel Xeon Gold 6130 je 2.1 GHz.  Por kutimaj
ĉifrosistemoj oni uzas 2048 aŭ eĉ 4096bitajn nombrojn.

La interesa demando pri unudirektaj funkcioj estas, ĉu oni fakte estas certa,
ke la inversa direkto estas tiom multe pli malfacila. Fakte oni nur, ĉar oni
dum jardekoj de klopodoj ne sukcesis trovi pli facilan metodon.  Almenaŭ
funkciantan sur klasikaj komputiloj.


\section{Minaco de kvantuma komputilado}

La supozo ke la faktorigo de primprodkto estas malfacila sur klasika komputilo
ĝis nun staras.  Sed en la 1990aj jaroj oni teorie inventis la kvantuman
komputilon.  Kvankam ĝi tiatempe estis nur matematika modelo, \textsc{Peter
  Shor} inventis por ĝi algoritmon por faktorigi primproduktojn kun multe
malpli alta komplekseco.  Por kompreni la algoritmon de Shor, ni unue devas
kompreni la principojn de kvantuma komputilo.


\subsection{Principoj de kvantuma komputilo}

Klasika komputilo ĉiam havas difinitan enigon, difinitan operacion kaj tial
ankaŭ difinitan eligon, t.e. rezulton.  La stato de la komputilo ĉiam estas
difinita. Tiu principo estas montrata en figuro \ref{fig:klasika-komputilo}.

\begin{figure}
  \begin{tikzpicture}[>=stealth,shorten >=1pt]
    \begin{scope}[every node/.style=draw,inner xsep=15pt]
      \node [draw] (input) {$5$};
      \node [draw, right=3em of input] (operation) {$+3$};
      \node [draw, right=3em of operation] (output) {$8$};
    \end{scope}
    \node [above=0.1em of input] {enigo};
    \node [above=0.1em of operation] {operacio};
    \node [above=0.1em of output] {eligo};

    \draw [->] (input) -- (operation);
    \draw [->] (operation) -- (output);
  \end{tikzpicture}
  \caption{Klasika komputilo havas difinitan staton.  La eniga registro havas
    staton \texttt{3}, la eliga registro havas staton \texttt{5}.}
  \label{fig:klasika-komputilo}
\end{figure}

Kontraste al klasika komputilo, kvantuma komputilo ne estas en difinita stato
sed en \emph{superpozicio} de pluraj statoj samtempe.  La enigo estas ne unu
difinita nombro, sed superpozicio de pluraj. La eligo estas la superpozicio de
ĉiuj enigoj kun la operacio aplikita kiel montrata en figuro
\ref{fig:kvantuma-komputilo}.

\begin{figure}
  \begin{tikzpicture}[>=stealth,shorten >=1pt]
    \begin{scope}[every node/.style=draw]
      \node [draw] (input) {
        $\left|\textcolor{red}{1}\right> + \left|\textcolor{blue}{2}\right> +
        \left|\textcolor{magenta}{3}\right>
        + \left|\textcolor{green}{4}\right> + \left|\textcolor{cyan}{5}\right> $
      };
      \node [draw, right=1em of input] (operation) {$+3$};
      \node [draw, right=1em of operation] (output) {
        $
        \left|\textcolor{red}{4}\right> + \left|\textcolor{blue}{5}\right> +
        \left|\textcolor{magenta}{6}\right>
        + \left|\textcolor{green}{7}\right> + \left|\textcolor{cyan}{8}\right>
        $};
    \end{scope}
    \node [above=0.1em of input] {enigo};
    \node [above=0.1em of operation] {operacio};
    \node [above=0.1em of output] {eligo};

    \draw [->] (input) -- (operation);
    \draw [->] (operation) -- (output);
  \end{tikzpicture}
  \caption{La eniga registro de kvantuma komputilo estas superpozicio de pluraj
    statoj, same la eliga registro.}
  \label{fig:kvantuma-komputilo}
\end{figure}

Superpozicio signifas ke la registro estas kvazaŭ samtempe en pluraj statoj.
Kiam oni kontrolas la staton de la registro, la superpozicio kolapsas kaj
restas hazarde unu el le statoj de la superpozicio.

Ni ja lernis, ke por faktorigo de du primoj oni konas nur la metodon, elprovi
ĉiujn eblojn.  Do kio se oni metas superpozicion de ĉiuj ebloj al la eniga
registro de kvantuma komputilo?  La eliga registro tiam estas superpozicio de
ĉiuj produktoj. Sed tio ne helpas, ĉar se oni kontrolas la rezulton, la
superpozicio kolapsas hazarde al unu el la statoj kaj oni ne gajnis ion ajn.


\subsection{La algoritmo de Shor}

Meze de la 1990aj jaroj \textsc{Peter Shor} inventis algoritmon, kiu uzante
kvantuman komputilon kapablas faktorigi du nombrojn en logaritma
komplekseco. La principo estas, ke en la rezulta superpozicio jes, estas la
rezulto de pluraj enigoj. Sed per truko ni kaŭzas, ke ĉiuj netaŭgaj partoj de
la superpozicio sinnuligas kaj restas nur la dezirata. Ni nun traludas ĝin
matematike.

\minisec{Tasko: faktorigi la nombron}

\begin{equation}
  \label{eq:produkto}
  N = a b \;\text{kun}\; a, b \in \mathbb{N}
\end{equation}
%
Ni divenas $d$:
\begin{equation}
  \label{eq:diveno}
  1 < d < N
\end{equation}
%
Ni kalkulas la plej grandan komunan divizoron $\pgkd$ de $d$ kaj $n$.
\begin{equation}
  \label{eq:diveno-sukceso}
  \text{se} \pgkd(d, N) > 1 \Longrightarrow\text{sukceso – ni trovis faktorojn}
\end{equation}
%
Ni scias ke ekzistas nombro $p \in \mathbb{N}$ tiel ke:
\begin{equation}
  \label{eq:ekzistas-p}
  d^p = m N + 1 \;\text{kun}\; m \in \mathbb{N}
\end{equation}
%
Iomete rearanĝante la antaŭan ekvacion ni ricevas:
\begin{equation}
  \label{eq:dp-divizoroj}
  d^p - 1 = \left(d^{p/2} + 1\right)\left(d^{p/2} - 1\right) = m N
\end{equation}
%
Se $p$ estas para, la unu du esprimoj $\left(d^{p/2} + 1\right)$ kaj
$\left(d^{p/2} - 1\right)$ estas faktoro de $N$. Oni povas kalkuli ke en
$37,5 \%$ de la divenoj tio estas la kazo.

La tasko do, estas trovi la $p$ de nia diveno $d$. Se ni tiam estas inter tiuj
$37,5 \%$ ni sukcesis, se ne, ni ripetas kaj post kelkaj provoj kun granda
probableco trovis divizoron de $p$.

Sekvas nun la kvantuma parto de la algoritmo de Shor. Unue kelkaj ekvacioj. Por
ĉiuj niaj divenoj $d$ ni povas trovi por ĉiu $i\in\mathbb{N}$ du naturajn
nombrojn $m_i$ kaj $r_i$ tiel ke:
\begin{equation}
  \label{eq:di-rilato}
  d^i = m_i N + r_i
\end{equation}
%
Se ni tiun ekvacion multobligas kun \eqref{eq:ekzistas-p} ni ricevas:
\begin{equation}
  \label{eq:di-p-rilato}
  d^{i+p} = m_{i+p} N + r_i
\end{equation}
%
Ĉar $d$, $m$, kaj $N$ estas naturaj nombroj, $r$ estas la resto (la modulo) de
la divido $d_i/N$
\begin{equation}
  \label{eq:di-mod-ri}
  d^{i+p}\mod N = r_i
\end{equation}

Tio estas sufiĉe interesa resulto, ĉar tio signifas, ke ni trovas la saman
$r_i$ por ĉiu $p$-a $i$. Do se ni trovas $r_i$ por ia nombro $i$, ni trovas la
saman $r_i$ por $i + p$ kaj por $i + 2p$ kaj por ĉiuj $i + np$.

Nun al la kvantuma komputilo. Ni komencas per superpozicio de ĉiuj eblaj
nombroj por $p$.
\[\left|1\right> + \left|2\right> + \left|3\right> + \left|4\right> +
  \left|5\right> + \left|6\right> + \left|7\right> + \left|8\right> + \ldots \]
%
Al tiu eniga registro ni aplikas la operacion $d^x$ en kiu $d$ estas nia
diveno. Poste la stato de la kvantuma komputilo estas la jena:
\[\left|d^1\right> + \left|d^2\right> + \left|d^3\right> + \left|d^4\right> +
  \left|d^5\right> + \left|d^6\right> + \left|d^7\right> + \left|d^8\right> +
  \ldots\]
%
Nun ni aplikas la operacion $x\mod N$ kaj ricevas:
\[\left|r_1\right> + \left|r_2\right> + \left|r_3\right> + \left|r_4\right> +
  \left|r_5\right> + \left|r_6\right> + \left|r_7\right> + \left|r_8\right> +
  \ldots\]
%
Ni scias, ke la sama $r_i$ ripetiĝas ĉiujn $p$ fojojn. Do se $p=3$ aspektus
tia:
\[\left|r_1\right> + \left|r_2\right> + \left|r_3\right> + \left|r_1\right> +
  \left|r_2\right> + \left|r_3\right> + \left|r_1\right> + \left|r_2\right> +
  \ldots\]
%
Do se ni iel povas mezuri la periodon de la tiu konstanta ripetiĝo, ni havus
nian serĉatan valoron por $p$.

Por tio ekzistas la fizika metodo de kvantuma Fourier transformo. Fourier
transformoj estas matematika operacio, kalkuli la frekvencan spektron de ia
signalo. Kaj la kvantuma Fourier transformo mezuras la frekvencan spektron de
kvantuma superpozicio. La frekvenco estas la inverso de la periodo $p$.

Se ni do aplikas ĝin al la registro de nia kvantuma komputilo, nia kvantuma
komputilo restas en difinita stato:
\[\left|\frac{1}{p}\right>\]
%
Tiun staton ni povas mezuri kaj de tio kalkuli la valoron por $p$. Nun ni havas
la $37,5$ elcentan ŝancon ke ni jam havas niajn divizoron.

\section{Postkvantuma ĉifrado}

Ĝis nun la Shor algoritmo estas ne pli ol matematika modelo. Oni ja sukcesis
per kvantuma komputilo faktorigi la nombron $15$ sed ne pli altan nombron. Tio
signifas kaj la vojo ĝis kvantumaj komputiloj ankaŭ estas longa. Tamen neniu
scias, kiom rapida la evoluo de kvantumaj komputiloj estos. Ĉu ili endanĝerigas
nian komunikon jam post kvin jaroj? Ĉu post dek? Ĉu dudek? Aŭ eble eĉ neniam.

Pro tio nescio jam en la 2000aj jaroj ĉifrosciencistoj lanĉis la disciplinon de
\emph{postkvantuma ĉifrado}. La celo de postkvantuma ĉifrado estas elpensi
ĉifrosistemojn imunaj kontraŭ la atakoj de kvantuma komputilo. En 2017 la Usona
Nacia Instituto de Normoj kaj Teknologio (NIST) lanĉis konkurson en kiu
partoprentantoj provis aligi siajn kandidatojn por postkvantuma
ĉifrosistemo. La plej spertaj ĉifrosciencistoj de la mondo tiam klopodis trovi
malfortojn en tiuj kandidatoj. Post kvar rondoj en 2024 restis kvar algoritmoj
por kiu oni ne trovis funkciantan atakon. Unu el ili nomiĝas
\textsc{Crystals}-Kyber. Ĝi estas lielnomata \emph{laticbazita} algoritmo.


\subsection{Laticbazita ĉifrado}

Latico estas grupo de matematikaj punktoj kun la trajto, ke oni de ĉiu punkto
per taŭga kombinoj la samaj vektoroj povas atingi ĉiun alian punkton de la
grupo. Figuro \ref{fig:latico} montras ekzemplon por du dimensia latico.  Por
$n$-dimensia latico sufiĉas ajna grupo de $n$ vektoroj, kiuj ne estas
paralelaj. Tia vektorgrupo sufiĉanta por per kombino de ajna punkto de la
latico al ajna alia nomiĝas bazo.

\begin{figure}
  \begin{tikzpicture}
    \coordinate (Origin)   at (0,0);

    \coordinate (Bone) at (0.3,0.7);
    \coordinate (Btwo) at (0.7,0.1);

    \coordinate (BoneB) at ($3*(Bone)+7*(Btwo)$);
    \coordinate (BtwoB) at ($4*(Bone)+9*(Btwo)$);

    % Latice points along b1+b2

    \clip (-1, -1) rectangle (9, 4.5);

    \foreach \i in {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
      \foreach \j in {-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
        12, 13 ,14, 15}
      \draw [fill = black]($\i*(Bone)+\j*(Btwo)$) circle (2pt);
    }
    % Draw the vectors
    \draw [ultra thick,-latex] (Origin) -- (Bone) node [above left] {$b_1$};
    \draw [ultra thick,-latex] (Origin) -- (Btwo) node [below right] {$b_2$};
    \draw[fill=gray] ($3.1*(Bone)+4.2*(Btwo)$) circle (2pt);
    \draw [thick,-latex,magenta] (Origin) -- ($3*(Bone)+7*(Btwo)$) node [above left] {$b'_1$};
    \draw [thick,-latex,magenta] (Origin) -- ($4*(Bone)+9*(Btwo)$) node [above left] {$b'_2$};
    \draw[blue] ($3*(Bone)+4*(Btwo)$) circle (3pt) node [above left] {$K$};
    % \draw [->] (Origin) -- ++ ($-11*(BoneB)+9*(BtwoB)$);
    \draw[fill=gray] ($3.1*(Bone)+4.2*(Btwo)$) circle (2pt) node [above right]
    {$M$};
  \end{tikzpicture}
  \caption{Dudimensia latico kun la bazaj vektoroj $b_1$ kaj $b_2$}
  \label{fig:latico}
\end{figure}

En figuro \ref{fig:latico} ni vidas du bazojn por la sama latico, $(b_1, b_2)$
kaj $(b'_1, b'_2)$. Per kombino de la vektoroj $b_1$ kaj $b_2$ oni povas de ĉiu
punkto de la latico atingi ĉiujn aliajn de la latico. Same per kombino de
$b'_1$ kaj $b'_2$. Estas evidente ke per la $(b_1, b_2)$ estas pli facile ol
per la bazo $(b'_1, b'_2)$. Kvankam ambaŭ bazoj taŭgas, estas evidente ke estas
pli facile per la bazo $(b_1, b_2)$. Tial oni tiun bazon nomas bona bazo.

\subsubsection{Serĉado de la plej proksima vektoro}

La punkto $M$ en figuro \ref{fig:latico} ne estas latica punkto. La plej
proksima latica punkto estas evidente $K$. Tion ni bone povas vidi, ĉar ĉiuj
laticaj punktoj estas markitaj en la diagramo. Sed kio se ni ne havus tiun
helpon. Se ni daŭre havas la bonan bazon $(b_1, b_2)$ verŝajne ankaŭ estas sufiĉe
facile trovi $K$ de $M$. Sed kio, se ni havas nur la malbonan bazon
$(b'_1, b'_2)$? Tiam estas multe pli malfacile. Kaj jen unudirekta funkcio.

Ĉifrasistemo povas esti ekzemple ke Anjo elpensas la du vektorojn $(b_1, b_2)$
kaj el kombinoj de ili la vektorojn $(b'_1, b'_2)$. Tiujn vektorojn ŝi sendas
al Boĉjo. Boĉjo kodigas mesaĝon por Anjo kiel kombinon de $(b'_1, b'_2)$. La
rezulto estas $K$. Tiun punkton li iomete ŝovas hazarde al $M$ kaj sendas la
koordinatojn de $M$ al Anjo. Anjo konas la bonan bazon $(b_1, b_2)$ kaj per ĝi
povas facile trovi la latican punkton $K$ kaj poste rekonstrui la mesaĝon de
Boĉjo.

Tio estas ekzemplo por simpla laticbazita ĉifrosistemo. Montriĝas ke ĝi ne
estas sekura. Oni montris sukcesajn atakojn al ĝi.


\subsection{Kyber – la normigita laticbazita ĉifrosistemo}

La normigita kaj jam uzebla laticbazita ĉifrosistemo nomiĝas
\textsc{Crystals}-Kyber. Pincipe funkcias simile kiel ni antaŭe vidis grafike.


\subsubsection*{Matematikaj bazoj}

Por kompreni la Kyber algoritmon, ni unue devas enkonduki kelkajn matematikajn
bazojn.

\minisec{Modula aritmetiko}

Ĉifrosistemoj ĝenerale estas sistemoj kiuj laboras kun entjeraj
nombroj. Ili adicias, subtrahas, multobligas kaj dividas entjerojn. La problemo
kiu okazas en tia kalkulado estas, ke la rezultoj povas troi. Tio signifas, ke
la nombroj iĝas tro grandaj por la antaŭvidanta bitspaco. Por eviti tion oni
uzas modulan aritmetikon. Tia aritmetiko certigas, ke nenia operacio eksteras
antaŭviditan intervalon.

La matematika operatoro $\mod$ kalkulas la modulon de du entjeraj nombroj. La
modulo estas la resto de entjera divido. Ekzemple $17\mod 5 = 2$, ĉar se ni
entjere dividas $17 / 5$ oni ricevas $15$ kaj restas $2$. Krome ni devas
enkonduki la nocion de \textbf{entjera ringo}. La entjera ringo de de modulo
$q$ estas difinita kiel la aro de ĉiuj entjeroj de $0$ al $q-1$:
\begin{equation}
  \label{eq:entjera-ringo}
  \mathbb{Z}_q = \left\{0, 1, 2, \ldots, q-1\right\}
\end{equation}
%
Ene de $\mathbb{Z}_q$ al ĉia aritmetiko estas aplikata la modulo $q$. Tio
signifas ke nenia matematika operacio ene de $\mathbb{Z}_q$ eksteras la
intervalon $[0, q-1]$.  Oni povas konsideri la minutojn de horloĝo
$\mathbb{Z}_{60}$ ringo. Ne gravas, kiel oni turnas la minutan montrilon der
horloĝo, ĝi ĉiam montras al minuto inter $0$ kaj $59$.

\begin{figure}
  \begin{tikzpicture}
    \draw (0, 0) circle (5em);
    \foreach \n in {0,1,...,16} {%
      \pgfmathparse{-360 * \n / 17 + 90}\edef\a{\pgfmathresult}
      \draw [fill] (\a:5em) circle(2pt);
      \node at (\a:4.3em) {\tiny\n};
    }
    \node at (0, 0) {$\mathbb{Z}_{17}$};
  \end{tikzpicture}
  \caption{Ekzemplo por $\mathbb{Z}_{17}$ entjera ringo}
  \label{fig:entjera-ringo-17}
\end{figure}
%
Ekzemplaj operacioj en $\mathbb{Z}_{17}$ ringo montrita en estas la sekvaj. Oni
bone komprenas ilin, se oni traludas ilin en la diagramo de la ringo.
\ref{fig:entjera-ringo-17}:
\begin{itemize}
\item $9 + 15 = 7$
\item $9 - 15 = 11$
\item $9 \times 15 = 16$
\end{itemize}
%
En modula aritmetiko ni devas klarigi la \textbf{grandecon} de entjero
$\big\|n\big\|$. Ĝi estas difinita kvazaŭ kiel la distanco de entjero de la
nula punkto. En por horloĝa minuto tio estas kiom for ni estas de la plena
horo. Aŭ en la ekzemplo de $\mathbb{Z}_{17}$ ni havas
\[
  \big\|8\big\| = 8,\; \big\|9\big\| = 8,\; \big\|16\big\| = 1
\]
Entjero estas eta, se ĝi troviĝas proksime de la supra punkto de la horloĝo do se
\[
 \big\|n\big\| < q/2
\]

\minisec{Polinoma ringo}

Estu $\mathbb{Z}_q[x]$ aro de polinomoj kies koeficientoj estas elemento de $\mathbb{Z}_q$:
\begin{equation}
  \label{eq:polinomaro}
  \mathbb{Z}_q[x] = c_n x^{n-1} + c_{n-1} x^{n-2} + \ldots c_1
  \;\text{kun}\; c_n \in \mathbb{Z}_q \;\forall n
\end{equation}
%
Ekzempla aritmetiko por $\mathbb{Z}_7[x]$:
\begin{itemize}
\item $f(x) = 3x^3 + 4x^2 + 5$ kaj $g(x) = 2x^2 + 3x + 6$
\item $f(x) + g(x) = 3x^3 + 6x^2 + 3x + 4$
\item $f(x) - g(x) = 3x^3 + 2x^2 + 4x + 6$
\item $f(x) \times g(x) = 6x^5 + 3x^4 + 2x^3 + 6x^2 + x + 2$
\end{itemize}

En polinomaro $\mathbb{Z}_q[x]$ la koeficientoj ne povas eksteri $[0, q-1]$ sed
ja povas la grado kaj do la eksponentoj de la polinomo.  Por tio oni enkondukas
la nocion de \textbf{polinoma ringo}:
\begin{equation}
  \label{eq:polinoma-ringo}
  R_q = \mathbb{Z}_q[x] \mod \left(x^n+1\right)
\end{equation}
%
La polinoma ringo $R_q$ estas ĉiun polinomoj de $\mathbb{Z}_q[x]$ kun la grado
malpli ol $n$. Al ĉia operacio oni prenas la modulon de $\left(x^n+1\right)$
kaj tiel certigas ke la grado neniam superas $n$.

Ekzemplo po $R_{41}$
\[
  R_{41} = \mathbb{Z}_{41}[x](x^4-1)
\]
\[
  f(x) = 22x^3 + 17x^2 + 31 \; g(x) = x^3 + 19x^2 + 7x + 11
\]
\[
  f(x) \times g(x) = 24x^3 + 35x^2 + 35x + 39
\]

La modulo $R_q^k$ estas la polinomoj de grado $k$, do la vektoroj de longeco
$k$ de la polinoma ringo $R_q$. Se ni adicias du polinomojn el $R_q^k$ ni
adicias la vektorojn kaj por multobligi ilin ni multobligas la vektorojn.  Ni
difinas la grandecon de polinomo estas la maksimumo de la grandecoj de ties
koeficientoj.

\subsubsection{Rondigi en entjera ringoj}

Ni ankoraŭ bezonas unu lastan nocion por kompreni la ĉifrosistemon kaj tio
estas la \textbf{rondigo} en entjera ringo. En entjera ringo $\mathbb{Z}_q$ la
valoro $\bigl\lfloor\frac{q}{2}\bigr\rceil$ difinas la suban punkton de la
ringo. $\bigl\lfloor x\bigr\rceil$ estas la plej proksima entjero de $x$. En
\figuro \ref{fig:rondigo-entjera-ringo-17} ni vidas ke nombroj de $5$ ĝis $12$
rondiĝas al 9 kaj la aliaj al $0$.
%
\begin{figure}
  \begin{tikzpicture}
    \draw (0, 0) circle (5em);
    \foreach \n in {0,1,...,16} {%
      \pgfmathparse{-360 * \n / 17 + 90}\edef\a{\pgfmathresult}
      \draw [fill] (\a:5em) circle(2pt);
      \node at (\a:4.3em) {\tiny\n};
    }
    \draw (0:5em) -- (180:5em);

    \node (zero) at (90:2em) {$0$};
    \node (nine) at (270:2em) {$\bigl\lfloor \frac{q}{2} \bigr\rceil = 9$};
  \end{tikzpicture}
  \caption{Rondigo en entjera ringo -- en la supra duono ni rondigas al $0$,
    en la malsupra al $\bigl\lfloor\frac{q}{2}\bigr\rceil = 9$}
  \label{fig:rondigo-entjera-ringo-17}
\end{figure}

\subsubsection{La lernado kun eraroj problemo}

Ni elektas primnombron $q$ kaj tri entjerojn $j$, $k$, $l$ kun $k>l$ Ni nun
elektas la matricon de polinomoj $\mathbf{A} \in R_q^{k\times l}$ kaj la
vektoron de eta polinomoj $\mathbf{s}$. Per multobligado ni ricevas la vektoron
$\mathbf{t}$. Konsciu ke ĉiuj eroj de la matrico kaj la vektoroj estas
polinomoj kaj ne simplaj nombroj.
\[
  \begin{pmatrix}
    t_1 \\ t_2 \\ \vdots \\ t_l \\ \vdots \\ t_k \\
  \end{pmatrix}
  =
  \begin{pmatrix}
    a_{11} & a_{12} & \cdots & a_{1l} \\
    a_{21} & a_{22} & \cdots & a_{2l} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{l1} & a_{l2} & \cdots & a_{ll} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{k1} & a_{k1} & \cdots & a_{kl} \\
  \end{pmatrix}
  \begin{pmatrix}
    s_1 \\ s_2 \\ \vdots \\ s_l \\
  \end{pmatrix}
\]
%
Se ni scias $\mathbf{A}$ kaj $\mathbf{t}$ ni povas facile kalkuli per lineara
algebro la vektoron $\mathbf{s}$. Ni enkondukas denove etan eraran vektoron
$\mathbf{e}$ tiel ke
\begin{equation}
  \label{eq:leranado-kun-eraro}
  \begin{pmatrix}
    t_1 \\ t_2 \\ \vdots \\ t_l \\ \vdots \\ t_k \\
  \end{pmatrix}
  =
  \begin{pmatrix}
    a_{11} & a_{12} & \cdots & a_{1l} \\
    a_{21} & a_{22} & \cdots & a_{2l} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{l1} & a_{l2} & \cdots & a_{ll} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{k1} & a_{k1} & \cdots & a_{kl} \\
  \end{pmatrix}
  \begin{pmatrix}
    s_1 \\ s_2 \\ \vdots \\ s_l \\
  \end{pmatrix}
  +
  \begin{pmatrix}
    e_1 \\ e_2 \\ \vdots \\ e_l \\ \vdots \\ e_k \\
  \end{pmatrix}
\end{equation}
Se ni nun scias $\mathbf{A}$ kaj $\mathbf{t}$ ni ne povas facile kalkuli simile
kiel ni an la latico ne povis trovi la plej proksiman latican punkton. Do jen
unudirekta funkcio. Do ni povas uzi $(\mathbf{A}, \mathbf{t})$ kiel publikan
ŝlosilon kaj $s$ kiel privatan ŝlosilon.

\subsubsection{La Kyber algoritmo}

Por partopreni la komunikadon Anjo kreas ŝlosilon per la jenaj paŝoj:
\begin{itemize}
\item Ŝi elektas matricon $\mathbf{A} \in R_q^{k\times k}$ kaj etajn vektorojn
  $\mathbf{s}$ kaj $\mathbf{e}$ de longeco $k$.
\item Ŝi kalkulas
  \begin{equation}
    \label{eq:kalkulo-t}
    \mathbf{t} = \mathbf{A}\mathbf{s} + \mathbf{e}
  \end{equation}
\item $\mathbf{s}$ estas ŝia privata ŝlosilo kaj $(\mathbf{A}, \mathbf{t})$ la
  publika.
\end{itemize}

Boĉjo volas sendi ĉifritan mesaĝon $m$ al Anjo. $m$ konsistas el $n$ bitoj kaj
oni povas skribi ĝin kiel polinomon $n$-gradan kies koeficientoj estas $0$ aŭ
$1$. Ekzemple por $q = 137$ kaj mesaĝo $m = (1101)_2$. Skribite iel polinomo la
mesaĝo estas:
\[
   m = x^3 + x^2 + 1
\]
Ĉar tio estas eta polinomo li multobligas ĝin per
$\bigl\lfloor\frac{q}{2}\bigr\rceil$. Krome li elektas tri etajn vektorojn
$\mathbf{r}$, $\mathbf{e}_1$ kaj la etan polinomon $e_2$. Nun li kalkulas la
ĉifraĵon:
\begin{align}
  \mathbf{u} &= \mathbf{A}^T \mathbf{r} + \mathbf{e}_1 \label{eq:kalkulo-u}\\
  v &= \mathbf{t}^T\mathbf{r} + \bigl\lfloor\frac{q}{2}\bigr\rceil m + e_2 \label{eq:kalkulo-v}
\end{align}
La ĉifraĵo estas $(\mathbf{u}, v)$.

Por malĉifri Anjo povas rearanĝi la ekvaciojn iomete. Multobligante
ekvacion (\ref{eq:kalkulo-u}) per $\mathbf{s}^T$ ŝi povas dedukti helpe de
ekvacio (\ref{eq:kalkulo-t}):
\begin{equation}
  \label{eq:malĉifrado-paŝo}
  \mathbf{s}^T\mathbf{u} =
  \mathbf{s}^T\mathbf{A}^T\mathbf{r} + \mathbf{s}^T\mathbf{e}_1 =
  \mathbf{t}^T\mathbf{r} + \mathbf{e}^T\mathbf{r} + \mathbf{s}^T\mathbf{e}_1
\end{equation}
Kombinante tion kun ekvacio (\ref{eq:kalkulo-v}):
\begin{equation}
  \label{eq:malĉifrado}
  \bigl\lfloor\frac{q}{2}\bigr\rceil m = v - \mathbf{t}^T\mathbf{r} - e_2 =
  v - \mathbf{s}^T\mathbf{u} + \mathbf{e}^T\mathbf{r} + \mathbf{s}^T\mathbf{e}_1 - e_2
\end{equation}
Ĉar $\mathbf{e}$, $\mathbf{r}$, $\mathbf{s}$, $\mathbf{e}_1$ kaj $e_2$ estas etaj ni scias ke
\[
  \left|v - \mathbf{s}^T\mathbf{u} \right| \gg \left|\mathbf{e}^T\mathbf{r} + \mathbf{s}^T\mathbf{e}_1 - e_2\right|
\]
Do la polinomo $v - \mathbf{s}^T\mathbf{u}$ estas jam proksima al
$\bigl\lfloor\frac{q}{2}\bigr\rceil m$. Rondigante la polinomon
$v - \mathbf{s}^T\mathbf{u}$ ni ricevas $\bigl\lfloor\frac{q}{2}\bigr\rceil m$
kaj tiam ni povas facile kalkuli la klarmesaĝon $m$.

Ni vidas ke tiu algoritmo estas parenca al tiu de la serĉado de la plej
proksima vektoro. Same kiel tie oni devas koni la bonan bazon $(b_1, b_2)$ por
trovi la latican punkton, oni en Kyber decas koni la vektoron $\mathbf{s}$.

\section{Konkludo}

Ne estas certe, ĉu kvantumaj komputiloj iam ajn praktike povas minaci niajn
nuntempajn ĉifrosistemojn. Sed ni same ne povas esti certaj, ke tio ne jam
okazos en la venonta jardeko. Pro tio la invento de ĉifrosistemaj rezistaj
kontraŭ kvantumaj komputiloj estas en evoluo. La Kyber algoritmo, kiun ni en
tiu ĉi artikolo rigardis, estas tre esperplena kandidato fariĝi la bazo de
postkvantuma ĉifrado.

\end{document}

% Local Variables:
% jinx-languages: "eo"
% TeX-master: t
% End:
